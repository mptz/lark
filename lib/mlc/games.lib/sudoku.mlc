|MLC Notebook v1|

                          A Sudoku Solver in MLC

Copyright (c) 2009-2025 Michael P. Touloumtzis.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
THE USE OR OTHER DEALINGS IN THE SOFTWARE.

|____________________________________________________________Section_______

                       Solution Approach & Concepts

We solve Sudoku via depth-first search (DFS) with constraint propagation.
A proper Sudoku begins with constraints which admit exactly one solution.

On the way to finding this solution we need to represent each square in
the grid as being in one of the following states:

- Underconstrained (more than one possibility)
- Solved (exactly one possibility)
- Overconstrained (no possibilities)

A puzzle is solved when each of its squares is solved.

When a square transitions form underconstrained to solved, we propagate
that solution to all the square's peers (other squares in the same row,
column, or box) by removing the solution from the possibilities of peer
squares.  This may in turn solve one or more peer squares by leaving them
with a single remaining possibility.  When this happens, we cascade the
constraint propagation step, recursively, until all discovered solutions
are reflected in all relevant peers.

When starting on a puzzle our first step is to treat each clue as a
newly discovered solution, propagating each as above.  In some cases
this constraint propagation cascade will completely solve the puzzle
without any need to initiate search.

While searching, we guess a solution to an underconstrained square by
selecting one of its possibilities and propagating that solution as above.
Upon encountering an overconstrained square, we conclude that our guesses
are faulty and we must backtrack to revise them.

|________________________________Section #y9qEEMfF.3VvMRtww.Eb4LqHle_______
|.......Require #tzNuz8Mh.ZK1TSbod.gw_zhkMK
|.......Require #t29ihI7k.pn_OFpk4.8F3O9QPj
|.......Public

                          Square Representation

Sudoku puzzles use digits 1..9, but only as arbitrary distinguishable
sigils--they don't participate in any arithmetic operations.  So we
could replace them with letters, symbols, or Lucky Charms marshmallows
to create isomorphic puzzles.

In practice we replace the digits 1..N with the first N prime numbers.
This allows us to store not only individual values, but superpositions
of possible values (stored as the product of the possible primes) in
one natural number per square.
 
The value 1 indicates the square is overconstrained i.e. unsolvable.

An 'unconstrained' square has all possibilities, so its value is the
product of all N leading primes.  This is the initial state for non-clue
squares.

To support this representation we start with some mapping functions:

|:
|:	first-prime := 2.
|:	last-prime := 23.
|:	first-nine-primes := [2 | 3 | 5 | 7 | 11 | 13 | 17 | 19 | 23].
|:	prime-to-digit-key :=
|:		[ 0 | 0 | 1 | 2 | 0 | 3 | 0 | 4 | 0 | 0 | 0 | 5 |
|:		  0 | 6 | 0 | 0 | 0 | 7 | 0 | 8 | 0 | 0 | 0 | 9 ].
|:
|:	digit-to-prime := [d. at (d - 1, first-nine-primes)].
|:	prime-to-digit := [p. at (p, prime-to-digit-key)].
|:	unconstrained := first-nine-primes; cell-product.
|:

For testing, we may wish to construct a square containing multiple
digits.  We don't need this for a real board, as all real squares start
single-valued or unconstrained:

|:
|:	square-containing :=
|:		let { pmult := [p, d. p * digit-to-prime (d)] }
|:		[digits. gather (pmult, 1, digits)].
|:

|..........................................................................

|*
|* The fundamental solving operation is 'constraining' a square.
|* Given a square's current value and a value, remove that value from
|* the square's possible values.  There are 4 outcomes:
|*
|* (1) Square is unchanged; the given value was already impossible.
|* (2) Square is still underconstrained, but with one fewer possibility.
|* (3) Square is newly solved: we removed the penultimate possibility.
|* (4) Square is newly overconstrained: we removed the final possibility.
|*
|* For outcome (2) we'll want to replace the square's contents with
|* the now reduced possibilities (replacing is OK for 1 as well; it's
|* a no-op).  For outcome (3) (transition from unsolved to solved) we
|* have a new constraint to propagate to the square's peers.  For (4),
|* we've identified an earlier inconsistency and must backtrack.
|*

|* Remove the given value from the square if it's a possibility for the
|* square.  Return the new square (without the value) or the original
|* square if the value was already not a possibility.
|*
constrain-square := [square, value.
	let { without-value := square / value }
	[without-value; $is-integral? without-value | square]].

|* Return the solution (in digit form) of a completely solved square,
|* otherwise return 0.  Even when working with primes, this can be used
|* as a solved/not solved truth value.
|*
square-solution :=
	[square. [square <= last-prime? at (square, prime-to-digit-key) | 0]].

|* What are the possible values in a square?  Essentially prime factoring.
|* Needed for hypothesis testing.
|*
square-possibilities := [square.
	let { try := [accum, prime.
		[$is-integral (square / prime)? cons (prime, accum) | accum]]. }
	gather (try, [], first-nine-primes)].

|*
|* Grid representation.  A grid is represented as a 9*9-element cell,
|* using the prime number representation above for individual squares.
|*
|* One of the key grid operations is finding a square's "peers", i.e.
|* the other squares with which it shares a row, column, or box.  We
|* precalculate a "peer grid" which, for each square index 0..80,
|* contains row, column, and box arrays containing the square's peers.
|*

all-digits := [1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9].
num-digits := # all-digits.
grid-size := num-digits * num-digits.

grid-row-indexes := [
	[  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 ] |
	[  9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 ] |
	[ 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 ] |

	[ 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 ] |
	[ 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 ] |
	[ 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 ] |

	[ 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 ] |
	[ 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 ] |
	[ 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 ] ].

grid-col-indexes := [
	[  0 |  9 | 18 | 27 | 36 | 45 | 54 | 63 | 72 ] |
	[  1 | 10 | 19 | 28 | 37 | 46 | 55 | 64 | 73 ] |
	[  2 | 11 | 20 | 29 | 38 | 47 | 56 | 65 | 74 ] |

	[  3 | 12 | 21 | 30 | 39 | 48 | 57 | 66 | 75 ] |
	[  4 | 13 | 22 | 31 | 40 | 49 | 58 | 67 | 76 ] |
	[  5 | 14 | 23 | 32 | 41 | 50 | 59 | 68 | 77 ] |

	[  6 | 15 | 24 | 33 | 42 | 51 | 60 | 69 | 78 ] |
	[  7 | 16 | 25 | 34 | 43 | 52 | 61 | 70 | 79 ] |
	[  8 | 17 | 26 | 35 | 44 | 53 | 62 | 71 | 80 ] ].

grid-box-indexes := [
	[  0 |  1 |  2 |  9 | 10 | 11 | 18 | 19 | 20 ] |
	[  3 |  4 |  5 | 12 | 13 | 14 | 21 | 22 | 23 ] |
	[  6 |  7 |  8 | 15 | 16 | 17 | 24 | 25 | 26 ] |

	[ 27 | 28 | 29 | 36 | 37 | 38 | 45 | 46 | 47 ] |
	[ 30 | 31 | 32 | 39 | 40 | 41 | 48 | 49 | 50 ] |
	[ 33 | 34 | 35 | 42 | 43 | 44 | 51 | 52 | 53 ] |

	[ 54 | 55 | 56 | 63 | 64 | 65 | 72 | 73 | 74 ] |
	[ 57 | 58 | 59 | 66 | 67 | 68 | 75 | 76 | 77 ] |
	[ 60 | 61 | 62 | 69 | 70 | 71 | 78 | 79 | 80 ] ].

grid-groups := fuse (grid-row-indexes,
	       fuse (grid-col-indexes,
		     grid-box-indexes)).

gather-peers := [i.
	let { containing-i := [a, c. [found (i, c)? fuse (a, c) | a]] }
	gather (containing-i, [], grid-groups)].

peer-key := fill (grid-size, gather-peers).

|* The main interface to square -> peers: returns a grid with the given
|* square value in i's peers and value of 1 otherwise.  When we solve a
|* square, we construct such a peer grid as a constraint set restricting
|* the solved value from appearing in the node's peers.
|*
peer-grid := [i, s.
	let { peers := at (i, peer-key) }
	let { peer-but-not-self :=
		[j. [$and (i <> j, found (j, peers))? s | 1]] }
	fill (grid-size, peer-but-not-self)].

digit-to-string-key :=
	[" " | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"].
digit-to-string := [d. at (d, digit-to-string-key)].

|* Converting a grid to a string, so we can conveniently read off a
|* solution.  Includes converting from prime representation to digits.
|*
grid-to-string := [grid.
	let { digit-grid := morph (square-solution, grid) }
	let { hline := "\n+---+---+---+---+---+---+---+---+---+\n". }
	let {

	xform := [state, elem.
		let { str := #0 state.  i := #1 state. }
		let { eol := $is-integral ((i + 1) / 9). }
		let { sep := [eol? " |" ++ hline | " "]. }
		[str ++ "| " ++ digit-to-string (elem) ++ sep | i + 1]].

	}
	#0 gather (xform, ["grid:" ++ hline | 0], digit-grid)].

|* Ingesting puzzles.  For convenience, we start with digit puzzles using
|* 0 as 'no clue'/unconstrained.  initial-grid converts these digit grids 
|* to prime grids, and initial-constraints generates the constraints
|* arising from the clues.
|*
initial-value := [square. [square? digit-to-prime (square) | unconstrained]].
initial-grid := [source-grid. morph (initial-value, source-grid)].

|* Given two grids grid0 and grid1, return a list of peer grids for squares
|* solved in grid1 but not in grid0.  We'll apply these as constraints in
|* the next solution round.
|*
diff-grids := [grid0, grid1.
	let {

	diff-squares := [i, accum.
		let { square1 := at (i, grid1) }
		let { solution0 := at (i, grid0); square-solution.
		      solution1 :=       square1; square-solution. }
		[$and (solution1, solution0; $not)?
			cons (peer-grid (i, square1), accum) | accum]].

	} let {
	step := [self! i, accum.
		[i < grid-size? self (i + 1, diff-squares(i, accum)) | accum]]
	}
	step (0, nil)].

empty-grid := cell (grid-size, 0); initial-grid.
initial-constraints := [grid. diff-grids (empty-grid, grid)].

|* A constraint propagation step: given a grid and a list of constraint
|* grids, apply all of the given constraint grids to the original.  A
|* square might be overconstrained (1), solved, or remain unsolved during
|* this process.  The return value is simply a new grid identical to
|* source-grid except constrained as specified.
|*
|* We expect each square in the constraint grids to be either a prime
|* number (solved value) or 1 for unconstrained.  Multiple constraints are
|* applied not by products-of-primes but by multiple constraint grids.
|*
constrained-grid := [source-grid, constraint-grids.
	let {

	apply-constraints := [self! i, square, grids.

		|* If grids is nil, we made it through all constraints,
		|* so we must be either solved or underconstrained.
		|*
		[grids; is-nil? square |

		let { value := at (i, grids; car) }
		self (i, constrain-square (square, value), grids; cdr)]]

	} let { xform := [i, e. apply-constraints (i, e, constraint-grids)] }
	morph-with-index (xform, source-grid)].

|* Run constraint propagation to completion: each time we constrain a grid
|* we might solve some squares, which in turn produces another round of
|* constraints.  Keep applying constraints until we don't solve any squares.
|*
constrain := [self! grid, constraints.
	let { new-grid := constrained-grid (grid, constraints) }
	let { new-constraints := diff-grids (grid, new-grid) }
	[new-constraints; is-nil? new-grid | self (new-grid, new-constraints)]].

|* The constraint propagation above doesn't try to understand outcomes
|* like 'have we solved the puzzle?' or 'is the puzzle unsolvable'?  Here
|* we make that determination, and get a clue as to how to proceed via
|* hypothesis testing.  We return a number representing one of three
|* outcomes:
|*
|* - Solved (represented by grid-size)
|* - Not solved (represented by index of an ambiguous square with the
|*   fewest possibilities--this will be where we want to try guessing)
|* - Impossible (represented by -1)
|*
analyze-grid := [grid.
	let { test := [self! i, j, s.
		[i == grid-size? j |
		let { square := at (i, grid) }
		[square < first-prime? -1 |
			let { np := square-possibilities (square); length }
			[$and (np > 1, np < s)?
				self (i + 1, i, np) |
				self (i + 1, j, s)]]]] }
	test (0, grid-size, num-digits + 1)].

|* When we guess we need to replace a single square in a grid with the
|* guessed value--that's all this function does.
|*
guess-grid := [i, n, grid.
	let { xform := [j, e. [i == j? n | e]] }
	morph-with-index (xform, grid)].

|* Implement hypothesis testing.  When constraint propagation alone
|* doesn't yield a solution, we find the most-constrained square and
|* guess each possible value for it.  We propagate the constraint
|* resulting from the guess, then recursively apply the same procedure
|* to the resulting grid.  When we encounter an impossibility, backtrack
|* and apply another guess possibility.
|*
constrain-and-guess := [constrain-and-guess! grid0, constraints0.

	let { do-guess := [i, grid.
		let { try-each := [try-each! guesses.
			[guesses; is-nil? [] |
			let { guess := guesses; car }
			let { hypothesis := guess-grid (i, guess, grid) }
			let { constraints := cons (peer-grid (i, guess), nil) }
			let { recur :=
				constrain-and-guess (hypothesis, constraints) }
			[recur; is-nil? guesses; cdr; try-each | recur]]] }
		let { possibilities := at (i, grid); square-possibilities }
		try-each (possibilities)] }

	let { do-analyze := [grid.
		let { analysis := grid; analyze-grid }
		[analysis < 0? [] |
			[analysis == grid-size? grid |
				do-guess (analysis, grid)]]] }

	do-analyze (constrain (grid0, constraints0))].

|________________________________Section #YCVDw_AO.6HLOPjtd.y38Zzrkd_______
|.......Public

|* Use constrain-and-guess to apply the full solution procedure.
|*
try-solve := [digit-grid.
	let { prime-grid := digit-grid; initial-grid }
	constrain-and-guess (prime-grid, prime-grid; initial-constraints)].

|*
|* Test grids
|*

|* for testing
impossible-grid :=
	[ 5 | 3 | 0 | 0 | 7 | 0 | 0 | 0 | 0
	| 6 | 0 | 0 | 1 | 9 | 5 | 0 | 0 | 0
	| 0 | 9 | 8 | 0 | 0 | 0 | 0 | 6 | 0

	| 8 | 0 | 0 | 0 | 6 | 0 | 0 | 0 | 3
	| 4 | 0 | 0 | 8 | 0 | 3 | 0 | 0 | 1
	| 7 | 0 | 0 | 0 | 2 | 0 | 1 | 0 | 6	|* note extra 1

	| 0 | 6 | 0 | 0 | 0 | 0 | 2 | 8 | 0
	| 0 | 0 | 0 | 4 | 1 | 9 | 0 | 0 | 5
	| 0 | 0 | 0 | 0 | 8 | 0 | 0 | 7 | 9 ].

|* for copy & paste
blank-grid :=
	[ 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0

	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0

	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 ].

easy-grid :=
	[ 0 | 0 | 3 | 0 | 2 | 0 | 6 | 0 | 0
	| 9 | 0 | 0 | 3 | 0 | 5 | 0 | 0 | 1
	| 0 | 0 | 1 | 8 | 0 | 6 | 4 | 0 | 0

	| 0 | 0 | 8 | 1 | 0 | 2 | 9 | 0 | 0
	| 7 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 8
	| 0 | 0 | 6 | 7 | 0 | 8 | 2 | 0 | 0

	| 0 | 0 | 2 | 6 | 0 | 9 | 5 | 0 | 0
	| 8 | 0 | 0 | 2 | 0 | 3 | 0 | 0 | 9
	| 0 | 0 | 5 | 0 | 1 | 0 | 3 | 0 | 0 ].

euler96-grid :=
	[ 0 | 0 | 3 | 0 | 2 | 0 | 6 | 0 | 0
	| 9 | 0 | 0 | 3 | 0 | 5 | 0 | 0 | 1
	| 0 | 0 | 1 | 8 | 0 | 6 | 4 | 0 | 0

	| 0 | 0 | 8 | 1 | 0 | 2 | 9 | 0 | 0
	| 7 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 8
	| 0 | 0 | 6 | 7 | 0 | 8 | 2 | 0 | 0

	| 0 | 0 | 2 | 6 | 0 | 9 | 5 | 0 | 0
	| 8 | 0 | 0 | 2 | 0 | 3 | 0 | 0 | 9
	| 0 | 0 | 5 | 0 | 1 | 0 | 3 | 0 | 0 ].

wikipedia-grid :=
	[ 5 | 3 | 0 | 0 | 7 | 0 | 0 | 0 | 0
	| 6 | 0 | 0 | 1 | 9 | 5 | 0 | 0 | 0
	| 0 | 9 | 8 | 0 | 0 | 0 | 0 | 6 | 0

	| 8 | 0 | 0 | 0 | 6 | 0 | 0 | 0 | 3
	| 4 | 0 | 0 | 8 | 0 | 3 | 0 | 0 | 1
	| 7 | 0 | 0 | 0 | 2 | 0 | 0 | 0 | 6

	| 0 | 6 | 0 | 0 | 0 | 0 | 2 | 8 | 0
	| 0 | 0 | 0 | 4 | 1 | 9 | 0 | 0 | 5
	| 0 | 0 | 0 | 0 | 8 | 0 | 0 | 7 | 9 ].

inkala-2006-grid :=
	[ 8 | 5 | 0 | 0 | 0 | 2 | 4 | 0 | 0
	| 7 | 2 | 0 | 0 | 0 | 0 | 0 | 0 | 9
	| 0 | 0 | 4 | 0 | 0 | 0 | 0 | 0 | 0

	| 0 | 0 | 0 | 1 | 0 | 7 | 0 | 0 | 2
	| 3 | 0 | 5 | 0 | 0 | 0 | 9 | 0 | 0
	| 0 | 4 | 0 | 0 | 0 | 0 | 0 | 0 | 0

	| 0 | 0 | 0 | 0 | 8 | 0 | 0 | 7 | 0
	| 0 | 1 | 7 | 0 | 0 | 0 | 0 | 0 | 0
	| 0 | 0 | 0 | 0 | 3 | 6 | 0 | 4 | 0 ].

inkala-2010-grid :=
	[ 0 | 0 | 5 | 3 | 0 | 0 | 0 | 0 | 0
	| 8 | 0 | 0 | 0 | 0 | 0 | 0 | 2 | 0
	| 0 | 7 | 0 | 0 | 1 | 0 | 5 | 0 | 0

	| 4 | 0 | 0 | 0 | 0 | 5 | 3 | 0 | 0
	| 0 | 1 | 0 | 0 | 7 | 0 | 0 | 0 | 6
	| 0 | 0 | 3 | 2 | 0 | 0 | 0 | 8 | 0

	| 0 | 6 | 0 | 5 | 0 | 0 | 0 | 0 | 9
	| 0 | 0 | 4 | 0 | 0 | 0 | 0 | 3 | 0
	| 0 | 0 | 0 | 0 | 0 | 9 | 7 | 0 | 0 ].

norvig-grid :=
	[ 4 | 0 | 0 | 0 | 0 | 0 | 8 | 0 | 5
	| 0 | 3 | 0 | 0 | 0 | 0 | 0 | 0 | 0
	| 0 | 0 | 0 | 7 | 0 | 0 | 0 | 0 | 0

	| 0 | 2 | 0 | 0 | 0 | 0 | 0 | 6 | 0
	| 0 | 0 | 0 | 0 | 8 | 0 | 4 | 0 | 0
	| 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0

	| 0 | 0 | 0 | 6 | 0 | 3 | 0 | 7 | 0
	| 5 | 0 | 0 | 2 | 0 | 0 | 0 | 0 | 0
	| 1 | 0 | 4 | 0 | 0 | 0 | 0 | 0 | 0 ].

norvig-2-grid :=
	[ 4 | 0 | 0 | 0 | 0 | 0 | 8 | 0 | 5
	| 0 | 3 | 0 | 0 | 0 | 0 | 0 | 0 | 0
	| 0 | 0 | 0 | 7 | 0 | 0 | 0 | 0 | 0

	| 0 | 2 | 0 | 0 | 0 | 0 | 0 | 6 | 0
	| 0 | 0 | 0 | 0 | 8 | 0 | 4 | 0 | 0
	| 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0

	| 0 | 0 | 0 | 6 | 0 | 3 | 0 | 7 | 0
	| 5 | 0 | 0 | 2 | 0 | 0 | 0 | 0 | 0
	| 1 | 0 | 4 | 0 | 0 | 0 | 0 | 0 | 0 ].

nyt-medium-grid :=
	[ 0 | 7 | 0 | 1 | 0 | 0 | 0 | 0 | 6
	| 0 | 5 | 0 | 2 | 0 | 0 | 0 | 0 | 3
	| 4 | 0 | 2 | 0 | 0 | 0 | 0 | 0 | 0

	| 1 | 0 | 3 | 0 | 5 | 0 | 0 | 0 | 0
	| 0 | 0 | 9 | 6 | 0 | 7 | 0 | 0 | 0
	| 5 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0

	| 0 | 0 | 0 | 0 | 0 | 2 | 7 | 5 | 9
	| 0 | 0 | 0 | 9 | 0 | 0 | 0 | 0 | 8
	| 0 | 0 | 0 | 0 | 3 | 0 | 2 | 0 | 0 ].

reddit-hard-grid :=
	[ 0 | 0 | 0 | 9 | 0 | 0 | 1 | 0 | 2
	| 7 | 0 | 0 | 3 | 0 | 0 | 6 | 0 | 0
	| 0 | 0 | 2 | 0 | 0 | 0 | 0 | 3 | 0

	| 9 | 0 | 0 | 0 | 0 | 8 | 7 | 0 | 0
	| 3 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 9
	| 0 | 0 | 6 | 5 | 0 | 0 | 0 | 0 | 1

	| 0 | 1 | 0 | 0 | 0 | 0 | 4 | 0 | 0
	| 0 | 0 | 4 | 0 | 0 | 9 | 0 | 0 | 6
	| 8 | 0 | 3 | 0 | 0 | 6 | 0 | 0 | 0 ].

stuck-again-grid :=
	[ 0 | 0 | 0 | 5 | 0 | 0 | 0 | 0 | 0
	| 0 | 8 | 5 | 0 | 1 | 6 | 0 | 0 | 2
	| 0 | 0 | 7 | 0 | 0 | 8 | 0 | 0 | 0

	| 0 | 5 | 0 | 0 | 9 | 0 | 0 | 0 | 7
	| 0 | 0 | 1 | 0 | 0 | 2 | 9 | 0 | 0
	| 0 | 0 | 4 | 0 | 7 | 0 | 0 | 5 | 0

	| 2 | 3 | 0 | 0 | 0 | 0 | 6 | 0 | 0
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 9 | 0
	| 4 | 0 | 0 | 2 | 0 | 0 | 0 | 0 | 3 ].
