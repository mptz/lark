|* Ordinary-function list operations, for when we want regular names
|* instead of operators/primitives.
cons	:= [x, y. [x | y]]
car	:= [p. #0 p]
cdr	:= [p. #1 p]
nil	:= []
is-nil	:= #is-nil
is-pair	:= #is-pair

|* Basic list length (not using fold)
basic-length-step := [self, list, accum.	\
	[list; is-nil? accum | self (self, #1 list, accum + 1)]]
basic-length := [list. basic-length-step (basic-length-step, list, 0)]

|* We don't yet have a fold which permits early exit
|* Use [] as out-of-band value when n >= length of list
|* XXX wait for some Boolean operators to do this one
|* nth-step := [self, list, n.			\
|*	[

|* List fold and unfold, on which we base numerous other operations

fold-step := [self, state, step, list.		\
	[list; is-nil? state |			\
		self (self, step (state, #0 list), step, #1 list)]]
fold := [start, step, list. fold-step (fold-step, start, step, list)]

|* The unfold step function returns [done | [state | elem]]
|* where:	'done' is nonzero iff we're done unfolding;
|*		'state' is the new state;
|*		'elem' is the eleemnt to add to the list.
unfold-step := [self, state, step, list.			\
	step (state) [result.					\
		[#0 result? list |				\
			self (self, #0 #1 result, step,		\
			      [#1 #1 result | list])]]]
unfold := [start, step. unfold-step (unfold-step, start, step, nil)]

|******************** List helpers using fold ********************

length-step := [accum, _. accum + 1]
length := [list. fold (0, length-step, list)]

reverse-step := [accum, elem. cons (elem, accum)]
reverse := [list. fold (nil, reverse-step, list)]

|******************** List helpers using unfold ********************

|* Making a list of constant values
makelist := [n, k. unfold (n, [m. [m == 0 | [m - 1 | k]]])]

|* Iota (list of numbers 1..n)
iota-step := [n. [n == 0 | [n - 1 | n]]]
iota := [n. unfold (n, iota-step)]

|******************** More list operations ********************

append := [lh, lt. fold (lt, reverse-step, lh; reverse)]

map-step := [self, f, list, accum.		\
	[list; is-nil? reverse (accum) |	\
		self (self, f, #1 list, cons (f (#0 list), accum))]]
map := [f, list. map-step (map-step, f, list, nil)]
