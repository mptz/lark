#!/usr/bin/perl
#
# Copyright (c) 2009-2018 Michael P. Touloumtzis.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#

use strict;
use warnings;

my @ops0_debug = (
	'BREAK',	# debugger breakpoint
	'GC',		# run garbage collector
	'PRINTrr',	# print XXX temp
	'TRACE',	# trace output
);

# VPU terminology (there's no global standard for this):
# - A 'branch' is a nonsequential instructions.
# - A 'jump' is an unconditional branch.
# Branch address can be specified via immediate or register.
# Immediate branches are all IP-relative to support PIC.
# Register branches can be IP-relative or absolute.

my @ops1_load = (
	'LDG',		# load global
	'LDL',		# load literal
);

# Branches with register operands
my @ops1_branch = (
	'LDRR',		# load result register into GP register
);

my @ops1_arith = (
	'INC',		# increment
	'DEC',		# decrement
	'POS',		# convert nat to positive int
	'NEG',		# negate
	'ABS',		# absolute value (int to int)
	'MAG',		# magnitude (int to nat)
);

my @ops1_io = (
	'PRINT',	# print
);

my @ops2_reg = (
	'MOV',		# move value from one register to another
	'CMP',		# compare values in registers (3-way compare)
);

my @ops2_cmp_eq = (
	'EQ',		# test for equality
	'GTE',		# greater than or equal to
);

my @ops2_cmp_neq = (
	'LT',		# less than
	'NE',		# test for inequality
);

my @ops2_arith = (
	'ADD',		# addition
	'SUB',		# subtraction
	'MUL',		# multiplication
	'DIVT',		# integer division, truncate towards zero
			# floor towards -Inf not implemented yet; more
			# mathematical but less common in H/W
	'REMT',		# remainder of integer division truncated towards zero
);

#
# New instruction format starts here
#

# nullary operations; no registers
my @ops0 = (
	'ILL',		# illegal instruction
	'HALT',		# halt VM execution
	'NOP',		# no-operation
	'JI',		# jump relative immediate, unconditional
);

# unary operations on float64 registers
my @ops1_float = (
	'LDI.fd',	# load immmediate float
	'NEG.fd',	# negate float
	'PRN.fd',	# print float
	'ZERO.fd',	# load constant 0.0
);

# binary operations on float64 registers
my @ops2_float = (
	'ADD.fd',	# double-precision addition
	'SUB.fd',	# double-precision subtraction
	'MUL.fd',	# double-precision multiplication
	'DIV.fd',	# double-precision division
	'MOV.fd',	# move float between registers
);

# unary operations on word registers
# XXX need CLZ, others?
my @ops1_word = (
	# constant loads
	'ZERO.w',	# load constant 0; redundant with XOR.w Wn Wn
	'ONE.w',	# load constant 1
	'TWO.w',	# load constant 2
	# comparison operations
	'EQZ.w',	# equal to zero?
	'NEZ.w',	# not equal to zero?
	# arithmetic operations
	'DEC.w',	# signed/unsigned decrement
	'INC.w',	# signed/unsigned increment
	'NEG.o',	# negate offset
	# bitwise & boolean operations
	'NOT.w',	# bitwise not
	'NOTL.w',	# logical not
	'POPCT.w',	# population count
	# jump operations
	'JR.o',		# relative jump (ip += wN)
	'JRD.o',	# relative jump (ip += wN * 2) for dispatch tables
	# other operations
	'LDI.w',	# load immediate word
	'LDRR.w',	# load result register
	'PRN.c',	# print character
	'PRN.o',	# print offset
	'PRN.w',	# print word
);

# binary operations on word registers
# XXX need left & right shift instructions
my @ops2_word = (
	# comparison operations
	'EQR.w',	# word equality, stored in target register
	'NER.w',	# word inequality, stored in target register
	'LTR.o',	# signed integer less-than, to target
	'LTR.w',	# unsigned integer less-than, to target
	'GTER.o',	# signed integer greater-than-or-equal-to, to target
	'GTER.w',	# unsigned integer greater-than-or-equal-to, to target
	# arithmetic operations
	'ADD.w',	# unsigned integer addition
	'SUB.w',	# unsigned integer subtraction
	'MUL.w',	# unsigned integer multiplication
	'DIVT.o',	# signed integer division, truncated towards zero
	'DIVT.w',	# unsigned integer division, truncated towards zero
	'REMT.o',	# remainder of truncated unsigned division as in DIVT.o
	'REMT.w',	# remainder of truncated unsigned division as in DIVT.w
	# bitwise & boolean operations
	'ANDL.w',	# logical AND
	'AND.w',	# bitwise AND
	'ASR.w',	# arithmetic shift right
	'LSL.w',	# logical shift left
	'LSR.w',	# logical shift right
	'ORL.w',	# logical OR
	'OR.w',		# bitwise OR
	'XOR.w',	# bitwise XOR
	# other operations
	'MOV.w',	# move between registers
);

my @ops2_word_nat = (
	'EQZ.wn',	# nat equal to zero?
	'NEZ.wn',	# nat not equal to zero?
);

#
# For some branching operations (the ones not relative to the instruction
# pointer), we dispatch to the current instruction--which has presumably
# been modified by the operation itself--rather than to the next one.
# We don't use this technique for all branches--the standard use of 'NEXT'
# allows 0-based IP-relative jumps.
#
my %ops_absolute = ();
$ops_absolute{$_} = 1 foreach (
	'JA.w'		# XXX obsolete now
);

#
# For some binary operations, like comparisons and moves, it doesn't make
# sense to generate implementations with identical source & target registers.
#
my %ops_distinct = ();
$ops_distinct{$_} = 1 foreach (
	'EQR.w', 'NER.w', 'LTR.o', 'LTR.w', 'GTER.o', 'GTER.w',
	'AND.w', 'OR.w',
	'MOV.fd', 'MOV.w',
);

my $fl_all = 'nsz';
my $fl_integral = 'nz';
my $fl_numeric = 'nz';
my $fl_signed = 'z';

my %ops_flavors = (

	'ABS' =>	'z',		# for now, should be all signed
	'ADD' =>	$fl_numeric,
	'CMP' =>	$fl_all,
	'DEC' =>	$fl_integral,
	'DIVT' =>	$fl_integral,
	'EQ' =>		$fl_numeric,
	'GTE' =>	$fl_numeric,
	'INC' =>	$fl_integral,
	'LDG' =>	'kh',
	'LDL' =>	$fl_all,
	'LIT' =>	$fl_all,
	'LT' =>		$fl_numeric,
	'MAG' =>	'z',		# for now, should be all signed
	'MUL' =>	$fl_numeric,
	'NEG' =>	'nz',
	'NE' =>		$fl_numeric,
	'POS' =>	'n',
	'PRINT' =>	$fl_all,	# XXX temp
	'REMT' =>	$fl_integral,
	'SUB' =>	$fl_numeric,

);

my %regbit = (
	'0' => 2** 0, '1' => 2** 1, '2' => 2** 2, '3' => 2** 3,
	'4' => 2** 4, '5' => 2** 5, '6' => 2** 6, '7' => 2** 7,
        '8' => 2** 8, '9' => 2** 9, 'A' => 2**10, 'B' => 2**11,
	'C' => 2**12, 'D' => 2**13, 'E' => 2**14, 'F' => 2**15,
);
my %regnum = (
	'0' =>  0, '1' =>  1, '2' =>  2, '3' =>  3,
	'4' =>  4, '5' =>  5, '6' =>  6, '7' =>  7,
        '8' =>  8, '9' =>  9, 'A' => 10, 'B' => 11,
	'C' => 12, 'D' => 13, 'E' => 14, 'F' => 15,
);

my $regsr = "0123456789ABCDEF";
my $regsfd = "01234567";
my $regsw =  "01234567";

sub expand_flavors {
	my @result = ();
	foreach my $opname (@_) {
		my $flavors = $ops_flavors{$opname};
		if (defined $flavors) {
			push (@result, $opname . $_)
				foreach split (//, $flavors);
		} else {
			push (@result, $opname);
		}
	}
	return @result;
}

my @ops0_legacy = expand_flavors (@ops0_debug);
my @ops1 = expand_flavors (@ops1_load, @ops1_branch,
			   @ops1_arith, @ops1_io);
my @ops2 = expand_flavors (@ops2_reg, @ops2_cmp_eq, @ops2_cmp_neq,
			   @ops2_arith);
my @ops_legacy = (@ops0_legacy, @ops1, @ops2);

my @ops_null = (@ops0, @ops0_legacy);
my @ops_float = (@ops1_float, @ops2_float);
my @ops_word = (@ops1_word, @ops2_word);

my @ops_all = (@ops_null, @ops1, @ops2, @ops_float, @ops_word, @ops2_word_nat);
my @ops0_all = (@ops_null);
my @ops1_all = (@ops1, @ops1_float, @ops1_word);
my @ops2_all = (@ops2, @ops2_float, @ops2_word, @ops2_word_nat);

# Replace '.' with '_' in opcodes for C language compability
my %op_labels = map { $_ => s/\./_/r } @ops_all;

my %opcodes = ();
{
	my $nextcode = 0;
	$opcodes{$_} = $nextcode++ foreach (@ops_all);
}

my %op_arities = ();
$op_arities{$_} = 0 foreach (@ops0_all);
$op_arities{$_} = 1 foreach (@ops1_all);
$op_arities{$_} = 2 foreach (@ops2_all);

my %op_regsets = ();
$op_regsets{$_} = 'F' foreach (@ops_float);
$op_regsets{$_} = 'W' foreach (@ops_word);
$op_regsets{$_} = 'WN' foreach (@ops2_word_nat);

my %op_regset1 = ();
$op_regset1{$_} = $regsfd foreach (@ops_float);
$op_regset1{$_} = $regsw  foreach (@ops_word, @ops2_word_nat);

my %op_regset2 = ();
$op_regset2{$_} = $regsfd foreach (@ops_float);
$op_regset2{$_} = $regsw  foreach (@ops_word);

my %op_selfcompare = ();
$op_selfcompare{$_} = 'm->rr = 1' foreach (expand_flavors (@ops2_cmp_eq));
$op_selfcompare{$_} = 'm->rr = 0' foreach (expand_flavors (@ops2_cmp_neq));

my %op_inline_args = (

	'LITc' =>	'c',
	'LITn' =>	'n',
	'LITo' =>	'o',
	'LITs' =>	's',
	'LITz' =>	'z',

	'JI' =>		'o',

	# XXX need to add LDG here
	'LDLc' =>	'c',
	'LDLd' =>	'w',
	'LDLg' =>	'w',
	'LDLn' =>	'n',
	'LDLo' =>	'o',
	'LDLs' =>	's',
	'LDLz' =>	'z',
	'LDI.fd' =>	'f',
	'LDI.w' =>	'w',
);

# Generate switch labels.
sub labels_op1 {
	my ($opname, $result) = @_;
	my $rtgt = $op_regset1{$opname} // $regsr;
	foreach my $reg1 (split (//, $rtgt)) {
		push (@$result, "$op_labels{$opname}_R${reg1}");
	}
}

sub labels_op2 {
	my ($opname, $result) = @_;
	my $rtgt = $op_regset1{$opname} // $regsr;
	my $rsrc = $op_regset2{$opname} // $regsr;
	foreach my $reg1 (split (//, $rtgt)) {
		foreach my $reg2 (split (//, $rsrc)) {
			next if (($reg1 eq $reg2) && $ops_distinct{$opname});
			push (@$result, "$op_labels{$opname}_" .
				        "R${reg1}_R${reg2}");
		}
	}
}

sub get_labels {
	my @result = ();
	foreach my $opname (@_) {
		my $arity = $op_arities{$opname};
		die unless defined $arity;
		if    ($arity == 0) { push (@result, $opname); }
		elsif ($arity == 1) { labels_op1($opname, \@result); }
		elsif ($arity == 2) { labels_op2($opname, \@result); }
		else { die "Arity undefined for $opname"; }
	}
	return @result;
}

#
# At this point we've assembled all the metadata we need, so we can start
# generating some output files.
#
open (my $fhdef, '>', 'src/vpu/opcodes.h') or die;
printf $fhdef ("#define op$op_labels{$_} 0x%04X\n", $opcodes{$_})
	foreach @ops_all;
close ($fhdef) or die;

open (my $fhnam, '>', 'src/vpu/opnames.c') or die;
printf $fhnam ("\t\"$_\",\n") foreach @ops_all;
close ($fhnam) or die;

# The lexer file oplex.l isn't automatically used; paste it into asm.l
# whenever it's changed (I know...).
sub lexer_line {
	my ($opname) = @_;
	return  "\"$opname\"  " .
		"yylval->opcode = op$op_labels{$_}; " .
		"return OP$op_arities{$opname}" .
		($op_regsets{$opname} // 'R') .
		uc ($op_inline_args{$opname} // '') .
		";\n";
}

open (my $fhlex, '>', 'src/vpu/oplex.l') or die;
printf $fhlex lexer_line($_) foreach @ops_all;
close ($fhlex) or die;

open (my $fhlab, '>', 'src/vpu/oplabels.c') or die;
print $fhlab ('		&&x' . $_ . ",\n") foreach (get_labels (@ops_all));
close ($fhlab) or die;

my $ldl_my_impl = 'm->r{reg1} = (word) *++(m->ip); m->mm |=  {reg1bit}';
my $ldl_mn_impl = 'm->r{reg1} = (word) *++(m->ip); m->mm &= ~{reg1bit}';

#
# Some remarks/concerns on the implementation:
#
# XXX trichotomy may break for float; implement less-than instead?
#
my %op_impls = (

'ABSz' =>	'm->r{reg1} = (word) int_abs((int_mt) m->r{reg1})',
'ADDn' =>	'm->r{reg1} = (word) nat_add((nat_mt) m->r{reg1}, (nat_mt) m->r{reg2})',
'ADDz' =>	'm->r{reg1} = (word) int_add((int_mt) m->r{reg1}, (int_mt) m->r{reg2})',
'BREAK' =>	'panic("Dispatched unimplemented BREAK instruction!\n")',
'CMPf' =>	'm->rr = ((fpw) m->r{reg1} > (fpw) m->r{reg2}) - ((fpw) m->r{reg1} < (fpw) m->r{reg2})',
'CMPn' =>	'm->rr = nat_cmp((nat_mt) m->r{reg1}, (nat_mt) m->r{reg2})',
'CMPs' =>	'strcmp3((str_mt) m->r{reg1}, (str_mt) m->r{reg2})',
'CMPz' =>	'm->rr = int_cmp((int_mt) m->r{reg1}, (int_mt) m->r{reg2})',
'DECn' =>	'm->r{reg1} = (word) nat_dec((nat_mt) m->r{reg1})',
'DECz' =>	'm->r{reg1} = (word) int_dec((int_mt) m->r{reg1})',
'DIVTn' =>	'm->r{reg1} = (word) nat_divt((nat_mt) m->r{reg1}, (nat_mt) m->r{reg2})',
'DIVTz' =>	'm->r{reg1} = (word) int_divt((int_mt) m->r{reg1}, (int_mt) m->r{reg2})',
'EQf' =>	'm->rr = (fpw) m->r{reg1} == (fpw) m->r{reg2}',
'EQn' =>	'm->rr = nat_cmp((nat_mt) m->r{reg1}, (nat_mt) m->r{reg2}) == 0',
'EQo' =>	'm->rr = (offset) m->r{reg1} == (offset) m->r{reg2}',
'EQz' =>	'm->rr = int_cmp((int_mt) m->r{reg1}, (int_mt) m->r{reg2}) == 0',
'GC' =>		'heap_force_gc()',
'GTEf' =>	'm->rr = (fpw) m->r{reg1} >= (fpw) m->r{reg2}',
'GTEn' =>	'm->rr = nat_cmp((nat_mt) m->r{reg1}, (nat_mt) m->r{reg2}) >= 0',
'GTEo' =>	'm->rr = (offset) m->r{reg1} >= (offset) m->r{reg2}',
'GTEz' =>	'm->rr = int_cmp((int_mt) m->r{reg1}, (int_mt) m->r{reg2}) >= 0',
'INCn' =>	'm->r{reg1} = (word) nat_inc((nat_mt) m->r{reg1})',
'INCz' =>	'm->r{reg1} = (word) int_inc((int_mt) m->r{reg1})',
'LDGh' =>	'm->r{reg1} = m->gp[(word) *++(m->ip)]; m->mm |=  {reg1bit}',
'LDGk' =>	'm->r{reg1} = m->gp[(word) *++(m->ip)]; m->mm &= ~{reg1bit}',
'LDLd' =>	$ldl_mn_impl,
'LDLn' =>	$ldl_my_impl,
'LDLs' =>	$ldl_my_impl,
'LDLz' =>	$ldl_my_impl,
'LDRR' =>	'm->r{reg1} = m->rr; m->mm &= ~{reg1bit}',
'LITc' =>	'panic("Dispatched LITc instruction!\n")',
'LITn' =>	'panic("Dispatched LITn instruction!\n")',
'LITs' =>	'panic("Dispatched LITs instruction!\n")',
'LITz' =>	'panic("Dispatched LITz instruction!\n")',
'LTf' =>	'm->rr = (fpw) m->r{reg1} < (fpw) m->r{reg2}',
'LTn' =>	'm->rr = nat_cmp((nat_mt) m->r{reg1}, (nat_mt) m->r{reg2}) < 0',
'LTo' =>	'm->rr = (offset) m->r{reg1} < (offset) m->r{reg2}',
'LTz' =>	'm->rr = int_cmp((int_mt) m->r{reg1}, (int_mt) m->r{reg2}) < 0',
'MAGz' =>	'm->r{reg1} = (word) int_mag((int_mt) m->r{reg1})',
'MOV' =>	'm->r{reg1} = m->r{reg2}; if (m->mm & {reg2bit}) m->mm ^= {reg1bit}; else m->mm &= ~{reg1bit}',
'MULn' =>	'm->r{reg1} = (word) nat_mul((nat_mt) m->r{reg1}, (nat_mt) m->r{reg2})',
'MULz' =>	'm->r{reg1} = (word) int_mul((int_mt) m->r{reg1}, (int_mt) m->r{reg2})',
'NEGn' =>	'm->r{reg1} = (word) nat_neg((nat_mt) m->r{reg1})',
'NEGz' =>	'm->r{reg1} = (word) int_neg((int_mt) m->r{reg1})',
'NEf' =>	'm->rr = (fpw) m->r{reg1} != (fpw) m->r{reg2}',
'NEn' =>	'm->rr = nat_cmp((nat_mt) m->r{reg1}, (nat_mt) m->r{reg2}) != 0',
'NEo' =>	'm->rr = (offset) m->r{reg1} != (offset) m->r{reg2}',
'NEz' =>	'm->rr = int_cmp((int_mt) m->r{reg1}, (int_mt) m->r{reg2}) != 0',
'POSn' =>	'm->r{reg1} = (word) nat_pos((nat_mt) m->r{reg1})',
'PRINTn' =>	'{ char *s = nat2str((nat_mt) m->r{reg1}); fputs(s, stdout); free(s); }',
'PRINTrr' =>	'if (0 > (offset) m->rr) ' .
		'printf("#-%zu", -(offset) m->rr); else ' .
		'printf("#+%zu", m->rr); ',
'PRINTs' =>	'fputs((const char *) strdata((str_mt) m->r{reg1}), stdout)',
'PRINTz' =>	'{ char *s = int2str((int_mt) m->r{reg1}); fputs(s, stdout); free(s); }',
'REMTn' =>	'm->r{reg1} = (word) nat_remt((nat_mt) m->r{reg1}, (nat_mt) m->r{reg2})',
'REMTz' =>	'm->r{reg1} = (word) int_remt((int_mt) m->r{reg1}, (int_mt) m->r{reg2})',
'SUBn' =>	'm->r{reg1} = (word) nat_sub((nat_mt) m->r{reg1}, (nat_mt) m->r{reg2})',
'SUBz' =>	'm->r{reg1} = (word) int_sub((int_mt) m->r{reg1}, (int_mt) m->r{reg2})',
'TRACE' =>	'panic("Dispatched unimplemented TRACE instruction!\n")',

		# XXX temporary; this load will break on 32-bit systems
		# we'd need 2-insn literals for float64 there
'LDI.fd' =>	'memcpy(&m->fd{reg1}, ++(m->ip), sizeof (float64))',
'MOV.fd' =>	'm->fd{reg1} = m->fd{reg2}',
'NEG.fd' =>	'm->fd{reg1} = -m->fd{reg1}',
'PRN.fd' =>	'printf("%.20g", (double) m->fd{reg1})',
'ZERO.fd' =>	'm->fd{reg1} = 0.0f64',

'ADD.fd' =>	'm->fd{reg1} += m->fd{reg2}',
'SUB.fd' =>	'm->fd{reg1} -= m->fd{reg2}',
'MUL.fd' =>	'm->fd{reg1} *= m->fd{reg2}',
'DIV.fd' =>	'm->fd{reg1} /= m->fd{reg2}',

# nullary operations; no registers
'ILL' =>	'panic("Dispatched illegal instruction!\n")',
'HALT' =>	'return',
'NOP' =>	'/* do nothing */',
'JI' =>		'm->ip += (offset) m->ip[1]',

# unary operations on word registers
'DEC.w' =>	'--m->w{reg1}',
'INC.w' =>	'++m->w{reg1}',
'EQZ.w' =>	'm->w{reg1} = m->w{reg1} == 0',
'NEZ.w' =>	'm->w{reg1} = m->w{reg1} != 0',
'JR.o' =>	'm->ip += m->w{reg1}',
'JRD.o' =>	'm->ip += m->w{reg1} * 2', # * 2 allows dispatch tables w/immeds
'LDI.w' =>	'm->w{reg1} = (word) *++(m->ip)',
'LDRR.w' =>	'm->w{reg1} = m->rr',
'NEG.o' =>	'm->w{reg1} = - (offset) m->w{reg1}',
'NOTL.w' =>	'm->w{reg1} = !m->w{reg1}',
'NOT.w' =>	'm->w{reg1} = ~m->w{reg1}',
'ONE.w' =>	'm->w{reg1} = 1',
'POPCT.w' =>	'm->w{reg1} = __builtin_popcountl(m->w{reg1})',
'PRN.c' =>	'printf("%c", (int) m->w{reg1})',
'PRN.o' =>	'if (0 > (offset) m->w{reg1}) ' .
		'printf("#-%zu", -(offset) m->w{reg1}); else ' .
		'printf("#+%zu", m->w{reg1}); ',
'PRN.w' =>	'printf("#%zu", m->w{reg1})',
'TWO.w' =>	'm->w{reg1} = 2',
'ZERO.w' =>	'm->w{reg1} = 0',

# binary operations on word registers
'ADD.w' =>	'm->w{reg1} += m->w{reg2}',
'SUB.w' =>	'm->w{reg1} -= m->w{reg2}',
'MUL.w' =>	'm->w{reg1} *= m->w{reg2}',
'DIVT.o' =>	'm->w{reg1} = (offset) m->w{reg1} / (offset) m->w{reg2}',
'DIVT.w' =>	'm->w{reg1} /= m->w{reg2}',
'REMT.o' =>	'm->w{reg1} = (offset) m->w{reg1} % (offset) m->w{reg2}',
'REMT.w' =>	'm->w{reg1} %= m->w{reg2}',
'EQR.w' =>	'm->w{reg1} = m->w{reg1} == m->w{reg2}',
'NER.w' =>	'm->w{reg1} = m->w{reg1} != m->w{reg2}',
'LTR.o' =>	'm->w{reg1} = (offset) m->w{reg1} < (offset) m->w{reg2}',
'LTR.w' =>	'm->w{reg1} = m->w{reg1} <  m->w{reg2}',
'GTER.o' =>	'm->w{reg1} = (offset) m->w{reg1} >= (offset) m->w{reg2}',
'GTER.w' =>	'm->w{reg1} = m->w{reg1} >= m->w{reg2}',
'AND.w' =>	'm->w{reg1} &= m->w{reg2}',
'ANDL.w' =>	'm->w{reg1} = m->w{reg1} && m->w{reg2}',
'ASR.w' =>	'm->w{reg1} = (offset) m->w{reg1} >> m->w{reg2}',
'LSL.w' =>	'm->w{reg1} <<= m->w{reg2}',
'LSR.w' =>	'm->w{reg1} >>= m->w{reg2}',
'MOV.w' =>	'm->w{reg1} = m->w{reg2}',
'OR.w' =>	'm->w{reg1} |= m->w{reg2}',
'ORL.w' =>	'm->w{reg1} = m->w{reg1} || m->w{reg2}',
'XOR.w' =>	'm->w{reg1} ^= m->w{reg2}',

# hybrid operations
'EQZ.wn' =>	'm->w{reg1} =  nat_is_zero((nat_mt) m->r{reg2})',
'NEZ.wn' =>	'm->w{reg1} = !nat_is_zero((nat_mt) m->r{reg2})',
);

sub print_impl {
	my ($fh, $opname, $reg1, $reg2) = @_;
	my $impl = $op_impls{$opname};
	die "No implementation for $opname\n" unless defined $impl;

	# Avoid generating tautological comparisons e.g. for LT R0, R0.
	# gcc complains about these.  Instead set the result register.
	if ((defined $reg1) && (defined $reg2) &&
	    ($reg1 eq $reg2) && (defined $op_selfcompare{$opname})) {
		$impl = $op_selfcompare{$opname};
	}

	my $x = 'x' . $op_labels{$opname} .
		(defined $reg1 ? "_R${reg1}" : '') .
		(defined $reg2 ? "_R${reg2}" : '') .
		': ' .  $impl .
		($ops_absolute{$opname} ? "; CURR;\n" : "; NEXT;\n");
	if (defined $reg1) {
		$x =~ s/{reg1}/$reg1/g;
		$x =~ s/{reg1bit}/$regbit{$reg1}/g;
	}
	if (defined $reg2) {
		$x =~ s/{reg2}/$reg2/g;
		$x =~ s/{reg2bit}/$regbit{$reg2}/g;
	}
	print $fh ($x);
};

sub print_insnargs {
	my ($fh, $opname) = @_;
	my $arg = $op_inline_args{$opname} // '0';
	print $fh ("\t'$arg',\t/* $opname */\n");
};

sub print_insncode {
	my ($fh, $opname, $reg1, $reg2) = @_;
	my $i = $opcodes{$opname};
	die "No opcode for $opname\n" unless defined $i;
	$i |= ($regnum{$reg1} << 16) if (defined $reg1);
	$i |= ($regnum{$reg2} << 24) if (defined $reg2);
	printf $fh ("\t0x%08X,	/* $opcodes{$opname}\t$opname */\n", $i);
};

open (my $fhimp, '>', 'src/vpu/opimpls.c') or die;
open (my $fharg, '>', 'src/vpu/opargs.c') or die;
open (my $fhico, '>', 'src/vpu/insncodes.c') or die;

sub print_op0 {
	my ($opname) = @_;
	print_insnargs ($fharg, $opname);
	print_impl ($fhimp, $opname);
	print_insncode ($fhico, $opname);
}

sub print_op1 {
	my ($opname) = @_;
	foreach my $reg1 (split (//, $op_regset1{$opname} // $regsr)) {
		print_insnargs ($fharg, $opname);
		print_impl ($fhimp, $opname, $reg1);
		print_insncode ($fhico, $opname, $reg1);
	}
}

sub print_op2 {
	my ($opname) = @_;
	my $rtgt = $op_regset1{$opname} // $regsr;
	my $rsrc = $op_regset2{$opname} // $regsr;
	foreach my $reg1 (split (//, $rtgt)) {
		foreach my $reg2 (split (//, $rsrc)) {
			next if (($reg1 eq $reg2) && $ops_distinct{$opname});
			print_insnargs ($fharg, $opname);
			print_impl ($fhimp, $opname, $reg1, $reg2);
			print_insncode ($fhico, $opname, $reg1, $reg2);
		}
	}
}

sub print_op {
	my ($opname) = @_;
	my $arity = $op_arities{$opname};
	die unless defined $arity;
	if    ($arity == 0) { print_op0 ($opname); }
	elsif ($arity == 1) { print_op1 ($opname); }
	elsif ($arity == 2) { print_op2 ($opname); }
	else { die "Arity undefined for $opname"; }
}

print_op ($_) foreach @ops_all;

close ($fhimp) or die;
close ($fharg) or die;
close ($fhico) or die;
