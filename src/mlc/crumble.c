/*
 * Copyright (c) 2009-2024 Michael P. Touloumtzis.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <assert.h>
#include <stddef.h>

#include <util/message.h>

#include "crumble.h"
#include "node.h"
#include "term.h"

/*
 * In the SCAM machine definition, the variable '*' (a five-pointed
 * star in the original) is a special variable marking the start of a
 * linear environment of explicit substitution nodes.  In this code
 * base it corresponds to node->prev == NULL.
 */
#define STAR NULL

static struct node_and_prev {
	struct node *node, *prev;
} crumble_term(struct term *term, struct node *prev, unsigned depth);

/*
 * crumble_flatten is called multiple times when we're crumbling an
 * application node, once to process the function and once for each
 * argument.  The intent is evident from the name: we replace nesting
 * with references (which you could admittedly view as another kind
 * of nesting, but which are also linearized into the environment
 * alongside the parent term so we can visit every term at a given
 * abstraction depth with left/right traversals).  Once that is done
 * we only need to "go deeper" to enter into abstractions.
 *
 * We eliminate nesting by returning a variable (bound, free, or
 * subst); if there's a nested term within the application, attach
 * that to the linear environment we're constructing (link it to
 * 'prev').  We return the slot variable to write into the
 * application along with the current head of the environment.
 */
static struct slot_and_prev {
	struct slot slot;
	struct node *prev;
} crumble_flatten(struct term *term, struct node *prev, unsigned depth)
{
	switch (term->variety) {
	case TERM_BOUND_VAR:
		/*
		 * Since we only crumble top-level terms, bound variable
		 * indexes are bounded by the current abstraction depth.
		 * Outside any abstractions (depth == 0) we shouldn't
		 * encounter a bound variable at all.
		 */
		assert(term->bv.up < depth);
		return (struct slot_and_prev) {
			.slot.variety = SLOT_BOUND,
			.slot.bv.up = term->bv.up,
			.slot.bv.across = term->bv.across,
			.prev = prev,
		};
	case TERM_FREE_VAR:
		return (struct slot_and_prev) {
			.slot.variety = SLOT_FREE,
			.slot.term = term,
			.prev = prev,
		};
	default:
		/*
		 * Since crumbled applications only contain indirections
		 * via variables and substitutions, any non-variable will
		 * be a separately-crumbled substitution.
		 */
		struct node_and_prev nap = crumble_term(term, prev, depth);
		return (struct slot_and_prev) {
			.slot.variety = SLOT_SUBST,
			.slot.subst = nap.node,
			.prev = nap.prev,
		};
	}
}

static struct node_and_prev
crumble_term(struct term *term, struct node *prev, unsigned depth)
{
	struct node_and_prev retval;

	switch (term->variety) {
	case TERM_ABS:
	case TERM_FIX:
		assert(term->abs.nformals > 0);
		assert(term->abs.nbodies == 1);
		retval.node = retval.prev =
			NodeAbs(prev, depth,
				crumble_term(term->abs.bodies[0],
					     STAR, depth + 1).prev,
				term->abs.nformals, term->abs.formals);
		/*
		 * We distinguish fixpoint abstractions from regular
		 * (nonrecursive) abstractions by the first parameter
		 * having variety SLOT_SELF rather than SLOT_PARAM.
		 */
		if (term->variety == TERM_FIX)
			retval.node->slots[1].variety = SLOT_SELF;
		break;
	case TERM_APP: {
		/*
		 * Crumbling an application involves replacing its non-
		 * variable components with explicit substitutions.
		 *
		 * When we do so, we set 'backref' in the referent to the
		 * referring slot.  Since non-star nodes generated by
		 * crumbling always have a reference count of 1, there's
		 * a unique referrer for each referent; this property will
		 * be lost as additional references accumulate during
		 * R-to-L traversal, but after we pass a node in R-to-L
		 * traversal we're done using its backreference anyway.
		 * 
		 *       +------------+
		 *       |   +--------|-----------------+
		 *       |   |        |                 |
		 *       |   |        v                 v
		 * ... [^X (^Y)] ... [@X, backref] ... [@Y, backref]
		 *       ^   ^               |                 |
		 *       |   |               |                 |
		 *	 +---|---------------+                 |
		 *	     +---------------------------------+
		 *
		 * We also set 'nref' in the referenced node to 1 to
		 * reflect the single application node referencing it.
		 */
		retval.node = prev = NodeApp(prev, depth, term->app.nargs);
		struct slot_and_prev sap = { .prev = prev };
		for (size_t i = 0; i <= term->app.nargs; ++i) {
			sap = crumble_flatten(
				i == 0 ? term->app.fun : term->app.args[i-1],
				sap.prev, depth);
			assert(slot_is_ref(sap.slot));
			if (sap.slot.variety == SLOT_SUBST) {
				assert(sap.slot.subst != prev);
				assert(sap.slot.subst->nref == 0);
				sap.slot.subst->nref = 1;
				sap.slot.subst->backref = &prev->slots[i];
			}
			prev->slots[i] = sap.slot;
		}
		retval.prev = sap.prev;
		break;
	}
	case TERM_BOUND_VAR:
		/*
		 * As above, bound variable indexes should be strictly
		 * less than the number of abstractions traversed so far.
		 */
		assert(term->bv.up < depth);
		retval.node = retval.prev =
			NodeBoundVar(prev, depth, term->bv.up, term->bv.across);
		break;
	case TERM_FREE_VAR:
		retval.node = retval.prev = NodeFreeVar(prev, depth, term);
		break;
	case TERM_NUM:
		retval.node = retval.prev = NodeNum(prev, depth, term->num);
		break;
	case TERM_PRIM:
		retval.node = retval.prev = NodePrim(prev, depth, term->prim);
		break;
	case TERM_TEST: {
		/*
		 * When we're done crumbling the test and hooking up
		 * pointers, we want the predicate to be evaluated before
		 * the test node itself (i.e. to its right in the same
		 * singly-linked environment, so evaluted first in right-
		 * to-left traversal).  It's thus handled identically to
		 * the function and values within an application, with
		 * the exception that we always use a substitution even
		 * for free and bound variables (hence crumble_term rather
		 * than crumble_flatten).
		 */
		retval.node = prev = NodeTest(prev, depth);
		assert(retval.node->nslots == 5);
		struct node_and_prev nap;

		nap = crumble_term(term->test.pred, prev, depth);
		assert(nap.node->nref == 0);
		retval.node->slots[0].subst = nap.node;
		nap.node->nref = 1;
		nap.node->backref = &retval.node->slots[0];
		retval.prev = prev = nap.prev;

		/*
		 * The consequent and alternative are referenced by the
		 * test node but not evaluated until *after* the test.
		 * Based on the test's outcome, reduction will attach
		 * one or the other to the reduction environment in
		 * place of the test node.
		 */
		assert(term->test.ncsqs == 1);
		nap = crumble_term(term->test.csqs[0], STAR, depth);
		assert(nap.node->nref == 0);
		retval.node->slots[1].subst = nap.node;
		retval.node->slots[2].subst = nap.prev;
		assert(term->test.nalts == 1);
		nap = crumble_term(term->test.alts[0], STAR, depth);
		assert(nap.node->nref == 0);
		retval.node->slots[3].subst = nap.node;
		retval.node->slots[4].subst = nap.prev;
		break;
	}
	default:
		panicf("Unhandled term variety %d\n", term->variety);
	}
	return retval;
}

struct node *crumble(struct term *term)
{
	return crumble_term(term, STAR, 0).prev;
}
