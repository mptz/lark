|MLC Notebook v1|

Tests to detect regressions of past bug fixes, with emphasis on subtle
reduction issues.

|:	Echo "Testing regression cases".

|============================================== #G2ztH6Bt.aJ-lBx1m.ouxYaQlN

This term gets stuck in the ML implementation which accompanied the
Accattoli, Condoluci, & Sacerdoti Coen paper; the rename rule filters
on Shared and Var cells and so doesn't consider renames pointing
to abstractions, which are critical.  Thus a rename pointing to an
abstraction gets skipped, the abstraction is hidden behind a rename &
is invisible to the beta-reduction steps, and we complete the R-to-L
traversal with intact beta redexes.

|:
|:	Def {Opaque} v := #v.
|:	[x. x] ([y. y]) (v).
|:

|============================================== #ReIAhzWX.aJ7lipO5.gVKhcl3b

After implementing primitives, this broke a depth check in uncrumble
(sometimes) and also surfaced a refcount assertion (sometimes).  I was
able to track down this inconsistent error to an erroneous reference
count decrement in the implementation of the '+' primitive which was
causing a number node to be gc'd while still in use.

|:
|:	[x. [y. x + y]] (5).
|:

|============================================== #udbPmSp4.Uspxz_Wf.Nk6b_S-l

Make sure we don't evaluate cells as though they were applications.
This evaluated to '2' before we fixed reduction to avoid this.

|:
|:	[x. x + 1]; [f. [f | 1]].
|:

|============================================== #EIHBK_rT.yaONsgZH.Q87UfeoY

This triggered an assertion failure after moving from a lifted,
term-based global environment to a preevaluated node-based global
environment.  The combination of an explicit substitution in the
second line (evaluating 'q') and the explicit substitution at the
head of 'q' in the environment triggered a "Missed rename chain"
panic in reduce.c.

|:
|:	q := [x. x] [y. y].
|:	q.
|:

|============================================== #kv-znR1C.yMAg-9Bw.UGn_ke6I

Another assertion failure trigger with the preevaluated global
environment.  This time the failed assertion is in unflattening:
"across < context->nformals".  The code below is a simplification
of a Church numeral predecessor implementation.

|:
|:	cons	:= [x, y. [f. y; f (x)]].
|:	phi	:= [x. cons (x, x)].
|:	pred	:= [n. n (phi)].
|:	pred.
|:
